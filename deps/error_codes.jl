# used to generate error codes in src/error_codes.jl
# if run with no args, prints the generated code to stdout
# with a file argument, write the code to that file
# e.g., julia deps/error_codes.jl src/error_codes.jl
#
# only needs to be re-run if the Travis diff job fails

using EzXML
using HTTP


const ERROR_CODE_APPENDIX = "https://www.postgresql.org/docs/current/errcodes-appendix.html"
const HEADER = "# autogenerated by deps/error_codes.jl using $ERROR_CODE_APPENDIX"

const SUCCESS_CLASS = "C00"
const WARNING_CLASSES = ("C01", "C02")
const EXTERNAL_CLASSES = ("C38", "C39")


pascalcase(str) = replace(titlecase(str), '_' => "")

error_code_html(url=ERROR_CODE_APPENDIX) = String(HTTP.get(url))

function error_code_table(html)
    parsed = parsehtml(html)

    return findfirst("//table[@summary='PostgreSQL Error Codes']", parsed)
end

parse_row(node) = map(nodecontent, findall("td/code", node))

function generate_error_codes(io, html=error_code_html())
    table = error_code_table(html)
    rows = findall("tbody/tr/td/code/../..", table)
    id_names = Set{String}()

    class_enum_io = IOBuffer()
    println(class_enum_io, "@cenum(Class,")
    error_enum_io = IOBuffer()
    println(error_enum_io, "@cenum(ErrorCode,")
    alias_io = IOBuffer()
    error_names_io = IOBuffer()
    println(error_names_io, "const ERROR_NAMES = Dict(")

    for row in rows
        code, name = parse_row(row)

        id_name = pascalcase(name)
        class = "C$(code[1:2])"
        error_code = "E$code"

        if endswith(code, "000")
            suffix = class in (SUCCESS_CLASS, WARNING_CLASSES...) ? "Class" : "ErrorClass"

            println(class_enum_io, "    $class,")
            println(alias_io, "\n\nconst $(id_name)$(suffix) = PQResultError{$class}\n")
        end

        if class in WARNING_CLASSES
            id_name *= "Warning"
        end

        if id_name in id_names
            if class in EXTERNAL_CLASSES
                id_name *= "Ext"  # like psycopg2
            else
                error("Duplicate identifier: $id_name")
            end
        end

        push!(id_names, id_name)

        println(alias_io, "const $(id_name) = PQResultError{$class, $error_code}")
        println(error_enum_io, "    $error_code,")
        println(error_names_io, "    $id_name => \"$id_name\",")
    end

    # unknown error
    class = "CUN"
    error_code = "EUNOWN"
    println(class_enum_io, "    $class,")
    println(alias_io, "\n\nconst UnknownErrorClass = PQResultError{$class}\n")
    println(alias_io, "const UnknownError = PQResultError{$class, $error_code}")
    println(error_enum_io, "    $error_code,")
    println(error_names_io, "    UnknownError => \"UnknownError\",")

    println(class_enum_io, ")")
    println(error_enum_io, ")")
    println(error_names_io, ")")

    foreach(seekstart, (class_enum_io, error_enum_io, alias_io, error_names_io))
    write(
        io,
        HEADER,
        "\n\n",
        class_enum_io,
        "\n",
        error_enum_io,
        alias_io,
        "\n",
        error_names_io,
    )

    return
end

function main()
    if length(ARGS) > 0
        open(ARGS[1], "w") do fp
            generate_error_codes(fp)
        end
    else
        generate_error_codes(stdout)
    end
end

abspath(PROGRAM_FILE) == @__FILE__() && main()
